<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Drachen ‚Äì Zerlegung wie GeoGebra</title>
<link rel="stylesheet" href="shared.css">
<script src="quiz-data.js"></script>
<script src="common-utils.js"></script>
</head>
<body>

<nav>
    <a href="index.html">‚Üê Zur√ºck zur √úbersicht</a>
    <a href="drachen.html" class="active">Drachen</a>
    <a href="parallelogramm.html">Parallelogramm</a>
    <a href="rhombus.html">Rhombus</a>
</nav>

<h2>Fl√§che eines Drachens ‚Äì Zerlegung (GeoGebra-Stil)</h2>

<div id="label">Zieh mich!</div>
<input id="slider" type="range" min="0" max="1" step="0.001" value="0">

<div class="canvas-container">
    <canvas id="canvas"></canvas>
</div>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const slider = document.getElementById("slider");

// Grundgr√∂√üen √§hnlich wie im GeoGebra-Material - will be scaled
const baseE = 300;
const baseF = 200;
const baseRatio = 0.75;
const baseX0 = 250;
const baseY0 = 150;

// Farben
const lightBlue = "#ADD8FF";
const darkBlue = "#0050FF";

const padding = 10; // Abstand f√ºr Text

function getScaleFactor() {
    return canvas.width / 900;
}

// Make canvas responsive
function resizeCanvas() {
    const container = canvas.parentElement;
    const containerWidth = container.clientWidth;
    const maxWidth = 900;
    const maxHeight = 450;
    
    canvas.width = Math.min(containerWidth, maxWidth);
    canvas.height = canvas.width * (maxHeight / maxWidth);
    
    draw();
}

// Initial resize and add listener
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const t = Number(slider.value);
    
    // Scale everything based on canvas size
    const scale = getScaleFactor();
    const e = baseE * scale;
    const f = baseF * scale;
    const ratio = baseRatio;
    const x0 = baseX0 * scale;
    const y0 = baseY0 * scale;

    // Punkte des Drachens
    const A = {x: x0, y: y0 + f/2};
    const B = {x: x0 + e*ratio, y: y0 + f};
    const C = {x: x0 + e, y: y0 + f/2};
    const D = {x: x0 + e*ratio, y: y0};
    const E = {x: x0 + e*ratio, y: y0 + f/2}; // Schnittpunkt e f
    
    const midF = (B.y + D.y) / 2; // Mittelpunkt f-Linie

    // Schrittgrenzen (wie GeoGebra)
    const heightStart = 0.15;  // H√∂henlinien erscheinen
    const colorStart = 0.30;   // Dreiecke werden farbig
    const mirrorStart = 0.55;  // Dreiecke spiegeln sich
    const moveStart = 0.70;    // Dreiecke bewegen sich nach oben
    const endStart = 0.80;     // Rechteck-Text erscheint

    // Grundform
    drawPolygon([A, C, D], lightBlue); // obere H√§lfte immer zeichnen
    if (t < colorStart) {
        drawPolygon([A, B, C], lightBlue); // untere H√§lfte nur bis Spiegelung
    }
    
    // Hilfslinien einblenden / verblassen
    drawLine(A.x, A.y, C.x, C.y, `rgba(0,0,0,${1-t})`);
    drawLine(B.x, B.y, D.x, D.y, `rgba(0,0,0,${1-t})`);
    if (t >= heightStart) {
        drawRectangle(x0, y0, e, f, "transparent", `rgba(0,0,0,${t})`, [5, 5]);
    }

    // H√∂he Text verschieben
    if (t >= heightStart) {
        const eStart = [x0 + (e/2), y0 + f/2 - padding];
        const eStop = [x0 + (e/2), y0 - padding];
        const ePos = [
            eStart[0] + (eStop[0] - eStart[0]) * Math.min((t - heightStart) / (colorStart - heightStart), 1),
            eStart[1] + (eStop[1] - eStart[1]) * Math.min((t - heightStart) / (colorStart - heightStart), 1)
        ];
        const fStart = [(x0 + e*ratio) + padding, midF - padding];
        const fStop = [x0 + e + padding, midF + padding];
        const fPos = [
            fStart[0] + (fStop[0] - fStart[0]) * Math.min((t - heightStart) / (colorStart - heightStart), 1),
            fStart[1] + (fStop[1] - fStart[1]) * Math.min((t - heightStart) / (colorStart - heightStart), 1)
        ];
        addText(ePos[0], ePos[1], "e");
        addText(fPos[0], fPos[1], "f");
    }
    
    // Dreiecke farbig markieren (aber nur bis es bewegt wird)
    if (t >= colorStart && t < mirrorStart) {
        drawPolygon([A, E, B], darkBlue);
        drawPolygon([C, E, B], darkBlue);
    }

    // Dreiecke spiegeln 
    if (t >= mirrorStart && t < moveStart) {
        const mirrorT = Math.min((t - mirrorStart) / (moveStart - mirrorStart), 1);
        const dx1 = (E.x - A.x) * mirrorT; // Spiegelungspfad linkes Dreieck
        const dx2 = (C.x - E.x) * mirrorT; // Spiegelungspfad rechtes Dreieck

        // linkes Dreieck
        drawPolygon([
            {x: A.x + dx1, y: A.y},
            {x: E.x - dx1, y: E.y},
            {x: B.x - dx1, y: B.y}
        ], darkBlue);

        // rechtes Dreieck
        drawPolygon([
            {x: C.x - dx2, y: C.y},
            {x: E.x + dx2, y: E.y},
            {x: B.x + dx2, y: B.y}
        ], darkBlue);
    }

    // nach oben verschieben
    if (t >= moveStart) {
        const moveT = Math.min((t - moveStart) / (endStart - moveStart), 1);
        const dy = (f/2) * moveT;

        // linkes Dreieck
        drawPolygon([
            {x: A.x, y: A.y - dy},
            {x: E.x, y: E.y - dy},
            {x: A.x, y: B.y - dy}
        ], darkBlue);

        // rechtes Dreieck
        drawPolygon([
            {x: C.x, y: C.y - dy},
            {x: E.x, y: E.y - dy},
            {x: C.x, y: B.y - dy}
        ], darkBlue);
    }

    // Endzustand: Rechteck
    if (t >= endStart) {
        const fontSize = Math.max(16, 26 * scale);
        ctx.font = fontSize + "px Arial";
        ctx.fillStyle = "green";
        ctx.fillText("‚Üí Rechteck", x0 + e + 40 * scale, y0 + 10 * scale);
    }
}

function addText(x, y, text, color="black", fontSizeBase="20px Arial") {
    const scale = getScaleFactor();
    const fontSize = Math.max(12, 20 * scale);
    ctx.font = fontSize + "px Arial";
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
}

function drawRectangle(x0, y0, width, height, fillColor = "rgba(0,0,0,0)", lineColor = "black", dash = []) {
    ctx.fillStyle = fillColor;
    ctx.setLineDash(dash);
    ctx.beginPath();
    ctx.rect(x0, y0, width, height);
    ctx.fill();
    ctx.strokeStyle = lineColor;
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawLine(x1, y1, x2, y2, color, dash = []) {
    ctx.strokeStyle = color;
    ctx.setLineDash(dash);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawPolygon(pts, fillColor, lineColor = "black") {
    ctx.fillStyle = fillColor;
    ctx.strokeStyle = lineColor;
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    for (const p of pts.slice(1)) ctx.lineTo(p.x, p.y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
}

slider.oninput = draw;
draw();
</script>

<!-- Quiz Section -->
<div class="quiz-section">
    <h2 style="color: #333; margin-bottom: 20px;">üßÆ Quiz: Berechne die Fl√§che!</h2>
    
    <div class="quiz-card">
        <div class="quiz-canvas-container">
            <canvas id="drachen-quiz-canvas"></canvas>
        </div>
        
        <div class="quiz-dimensions">
            <strong>Gegeben:</strong><br>
            Diagonale e = <span id="drachen-e">12</span> cm<br>
            Diagonale f = <span id="drachen-f">8</span> cm
        </div>
        
        <div class="quiz-hint">
            üí° Tipp: Die Formel f√ºr die Fl√§che eines Drachens lautet: A = (e √ó f) / 2
        </div>
        
        <div class="quiz-answer-section">
            <div class="quiz-input-group">
                <label for="drachen-answer">Deine Antwort:</label>
                <input type="number" id="drachen-answer" placeholder="z.B. 48">
                <span style="font-size: 18px;">cm¬≤</span>
                <button onclick="checkDrachenQuiz()" class="quiz-btn">Pr√ºfen</button>
            </div>
            
            <div id="drachen-result" class="quiz-result"></div>
            
            <button onclick="toggleDrachenSolution()" class="quiz-btn-secondary">L√∂sung anzeigen</button>
            <button onclick="newDrachenProblem()" class="quiz-btn-success">Neue Aufgabe</button>
            
            <div id="drachen-solution" class="quiz-solution">
                <strong>L√∂sung:</strong><br>
                A = (e √ó f) / 2<br>
                A = (<span id="drachen-sol-e">12</span> cm √ó <span id="drachen-sol-f">8</span> cm) / 2<br>
                A = <span id="drachen-sol-product">96</span> cm¬≤ / 2<br>
                A = <strong><span id="drachen-sol-answer">48</span> cm¬≤</strong>
            </div>
        </div>
    </div>
</div>

<script>
// Initialize quiz for drachen
currentProblems.drachen = 0;

function drawDrachenQuiz() {
    const canvas = document.getElementById('drachen-quiz-canvas');
    const ctx = canvas.getContext('2d');
    
    // Make quiz canvas responsive - match main canvas width
    const container = canvas.parentElement;
    const containerWidth = container.clientWidth;
    const maxWidth = 900;
    canvas.width = Math.min(containerWidth, maxWidth);
    canvas.height = canvas.width * 0.5; // Maintain aspect ratio
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const problem = getCurrentProblem('drachen');
    const scale = canvas.width / 300; // Base width was 300
    const e = problem.e * 10 * scale;
    const f = problem.f * 10 * scale;
    const x = canvas.width / 2, y = canvas.height / 2;
    
    // Draw shape
    ctx.fillStyle = '#ADD8FF';
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x, y - f/2);
    ctx.lineTo(x + e*0.6, y);
    ctx.lineTo(x, y + f/2);
    ctx.lineTo(x - e*0.4, y);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Draw dashed diagonal lines
    ctx.strokeStyle = '#666';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 5]);
    // Horizontal diagonal (e)
    ctx.beginPath();
    ctx.moveTo(x - e*0.4, y);
    ctx.lineTo(x + e*0.6, y);
    ctx.stroke();
    // Vertical diagonal (f)
    ctx.beginPath();
    ctx.moveTo(x, y - f/2);
    ctx.lineTo(x, y + f/2);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Labels
    const fontSize = Math.max(12, 16 * scale);
    ctx.font = fontSize + 'px Arial';
    ctx.fillStyle = '#333';
    ctx.fillText('e = ' + problem.e + ' cm', x - 30 * scale, y + f/2 + 25 * scale);
    ctx.fillText('f = ' + problem.f + ' cm', x + e*0.6 + 10 * scale, y);
}

function updateDrachenQuizDisplay() {
    const problem = getCurrentProblem('drachen');
    document.getElementById('drachen-e').textContent = problem.e;
    document.getElementById('drachen-f').textContent = problem.f;
    document.getElementById('drachen-sol-e').textContent = problem.e;
    document.getElementById('drachen-sol-f').textContent = problem.f;
    document.getElementById('drachen-sol-product').textContent = problem.e * problem.f;
    document.getElementById('drachen-sol-answer').textContent = problem.answer;
    drawDrachenQuiz();
}

// Redraw quiz on window resize
window.addEventListener('resize', function() {
    if (document.getElementById('drachen-quiz-canvas')) {
        drawDrachenQuiz();
    }
});

function newDrachenProblem() {
    newQuizProblem('drachen', updateDrachenQuizDisplay);
}

function checkDrachenQuiz() {
    const correct = getCurrentProblem('drachen').answer;
    checkQuizAnswer('drachen', correct);
}

function toggleDrachenSolution() {
    toggleQuizSolution('drachen');
}

// Initialize quiz
setupQuizEnterKey('drachen', checkDrachenQuiz);
drawDrachenQuiz();
</script>

</body>
</html>